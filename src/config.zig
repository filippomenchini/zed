const std = @import("std");

/// Available actions that can be triggered by key bindings
///
/// This enum defines all possible actions that the editor can perform
/// in response to user input. Each action represents a high-level command
/// that the editor understands.
///
/// Usage:
/// ```zig
/// const action = Action.quit;
/// ```
pub const Action = enum {
    quit, // Exit the editor
    // I'll add future actions here:
    // save, move_up, move_down, move_left, move_right, etc.
};

/// Represents a mapping between a key press and an editor action
///
/// A key binding associates a specific key (represented as a u8 byte value)
/// with an action that should be performed when that key is pressed.
///
/// Fields:
/// - key: The ASCII/control character code (0-255)
/// - action: The action to perform when this key is pressed
///
/// Examples:
/// ```zig
/// // Map 'q' key to quit action
/// const quit_binding = KeyBinding{ .key = 'q', .action = .quit };
///
/// // Map Ctrl+C to quit action
/// const ctrl_c_binding = KeyBinding{ .key = ctrlKey('c'), .action = .quit };
/// ```
pub const KeyBinding = struct {
    key: u8,
    action: Action,
};

/// Configuration structure that holds all key bindings for the editor
///
/// This structure acts as a lookup table for translating key presses
/// into editor actions. It provides a clean separation between the
/// user interface (key mappings) and the editor logic (actions).
///
/// The design allows for:
/// - Customizable key bindings without changing editor code
/// - Multiple keys mapped to the same action
/// - Easy testing with different configurations
/// - Runtime configuration changes (future feature)
pub const Config = struct {
    /// Array of key bindings that define the editor's input mapping
    ///
    /// This slice contains all active key bindings. The order doesn't matter
    /// for functionality, but you might want to organize them logically
    /// for maintainability (e.g., group movement keys together).
    key_bindings: []const KeyBinding,

    /// Find the action associated with a given key press
    ///
    /// This function performs a linear search through the key bindings
    /// to find a matching key. If multiple bindings exist for the same key,
    /// the first one found will be returned.
    ///
    /// Performance: O(n) where n is the number of key bindings
    /// For typical editor usage (< 100 bindings), this is perfectly adequate.
    /// I might change this in the future, a hash map could be a great fit!
    ///
    /// Parameters:
    /// - self: Pointer to the Config instance
    /// - key: The key code to look up (0-255)
    ///
    /// Returns:
    /// - The associated Action if key is found
    /// - null if no binding exists for this key
    ///
    /// Example:
    /// ```zig
    /// if (config.findAction(key_pressed)) |action| {
    ///     switch (action) {
    ///         .quit => return, // Exit the editor
    ///         // Handle other actions...
    ///     }
    /// } else {
    ///     // Key not bound to any action, maybe insert it as text
    /// }
    /// ```
    pub fn findAction(self: *const Config, key: u8) ?Action {
        for (self.key_bindings) |binding| {
            if (binding.key == key) {
                return binding.action;
            }
        }

        return null;
    }
};

/// Bitmask for extracting control character codes
///
/// This constant represents the bitmask used to convert regular ASCII
/// characters into their corresponding control character codes.
///
/// Value explanation:
/// - 0x1f in binary: 00011111
/// - This mask preserves only the lowest 5 bits of a character
/// - ASCII characters have their control equivalents in the 0-31 range
const ctrl_bitmask = 0x1f;

/// Convert a regular character to its control character equivalent
///
/// This function implements the standard method for generating control
/// characters that dates back to early computer terminals and teletypes.
///
/// How it works:
/// Control characters are generated by holding the Ctrl key while pressing
/// a letter. The terminal/keyboard hardware performs a bitwise AND operation
/// with 0x1f (31 in decimal, 00011111 in binary) to generate the control code.
///
/// Examples:
/// - 'A' (ASCII 65, binary 01000001) & 0x1f = 1 (Ctrl+A)
/// - 'C' (ASCII 67, binary 01000011) & 0x1f = 3 (Ctrl+C)
/// - 'Q' (ASCII 81, binary 01010001) & 0x1f = 17 (Ctrl+Q)
/// - 'Z' (ASCII 90, binary 01011010) & 0x1f = 26 (Ctrl+Z)
///
/// Why 0x1f?
/// - ASCII letters A-Z are in range 65-90 (uppercase) or 97-122 (lowercase)
/// - Control characters are in range 1-26
/// - The mask 0x1f clears the upper 3 bits, mapping both cases to 1-26
/// - This is why Ctrl+A produces the same code regardless of caps lock
///
/// Historical note:
/// This behavior was standardized in early computing when control characters
/// were the primary way to send commands to computers and terminals.
/// Even though we now have function keys and complex key combinations,
/// control characters remain fundamental to terminal-based applications.
///
/// Parameters:
/// - key: ASCII character (typically 'a'-'z' or 'A'-'Z')
///
/// Returns: The control character code (typically 1-26)
///
/// Example usage:
/// ```zig
/// const CTRL_C = ctrlKey('c');    // Returns 3
/// const CTRL_Q = ctrlKey('q');    // Returns 17
///
/// // Use in key binding:
/// .{ .key = ctrlKey('c'), .action = .quit }
/// ```
pub fn ctrlKey(key: u8) u8 {
    return key & ctrl_bitmask;
}
